// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"Konnect/internal/sdk/pkg/models/shared"
	"encoding/json"
	"fmt"
	"net/http"
)

// UpsertUpstreamRequestBodyAlgorithm - Which load balancing algorithm to use. Accepted values are: `consistent-hashing`, `least-connections`,` round-robin`. Default: `round-robin`.
type UpsertUpstreamRequestBodyAlgorithm string

const (
	UpsertUpstreamRequestBodyAlgorithmConsistentHashing UpsertUpstreamRequestBodyAlgorithm = "consistent-hashing"
	UpsertUpstreamRequestBodyAlgorithmLeastConnections  UpsertUpstreamRequestBodyAlgorithm = "least-connections"
	UpsertUpstreamRequestBodyAlgorithmRoundRobin        UpsertUpstreamRequestBodyAlgorithm = "round-robin"
)

func (e UpsertUpstreamRequestBodyAlgorithm) ToPointer() *UpsertUpstreamRequestBodyAlgorithm {
	return &e
}

func (e *UpsertUpstreamRequestBodyAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "consistent-hashing":
		fallthrough
	case "least-connections":
		fallthrough
	case "round-robin":
		*e = UpsertUpstreamRequestBodyAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertUpstreamRequestBodyAlgorithm: %v", v)
	}
}

// UpsertUpstreamRequestBodyClientCertificate - If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
type UpsertUpstreamRequestBodyClientCertificate struct {
	ID *string `json:"id,omitempty"`
}

// UpsertUpstreamRequestBodyHashFallback - What to use as hashing input if the primary hash_on does not return a hash (eg. header is missing, or no Consumer identified). Not available if hash_on is set to cookie.
type UpsertUpstreamRequestBodyHashFallback string

const (
	UpsertUpstreamRequestBodyHashFallbackNone       UpsertUpstreamRequestBodyHashFallback = "none"
	UpsertUpstreamRequestBodyHashFallbackConsumer   UpsertUpstreamRequestBodyHashFallback = "consumer"
	UpsertUpstreamRequestBodyHashFallbackIP         UpsertUpstreamRequestBodyHashFallback = "ip"
	UpsertUpstreamRequestBodyHashFallbackCookie     UpsertUpstreamRequestBodyHashFallback = "cookie"
	UpsertUpstreamRequestBodyHashFallbackURICapture UpsertUpstreamRequestBodyHashFallback = "uri_capture"
	UpsertUpstreamRequestBodyHashFallbackPath       UpsertUpstreamRequestBodyHashFallback = "path"
	UpsertUpstreamRequestBodyHashFallbackQueryArg   UpsertUpstreamRequestBodyHashFallback = "query_arg"
)

func (e UpsertUpstreamRequestBodyHashFallback) ToPointer() *UpsertUpstreamRequestBodyHashFallback {
	return &e
}

func (e *UpsertUpstreamRequestBodyHashFallback) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "consumer":
		fallthrough
	case "ip":
		fallthrough
	case "cookie":
		fallthrough
	case "uri_capture":
		fallthrough
	case "path":
		fallthrough
	case "query_arg":
		*e = UpsertUpstreamRequestBodyHashFallback(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertUpstreamRequestBodyHashFallback: %v", v)
	}
}

// UpsertUpstreamRequestBodyHashOn - What to use as hashing input. Using none results in a weighted-round-robin scheme with no hashing
type UpsertUpstreamRequestBodyHashOn string

const (
	UpsertUpstreamRequestBodyHashOnNone       UpsertUpstreamRequestBodyHashOn = "none"
	UpsertUpstreamRequestBodyHashOnConsumer   UpsertUpstreamRequestBodyHashOn = "consumer"
	UpsertUpstreamRequestBodyHashOnIP         UpsertUpstreamRequestBodyHashOn = "ip"
	UpsertUpstreamRequestBodyHashOnCookie     UpsertUpstreamRequestBodyHashOn = "cookie"
	UpsertUpstreamRequestBodyHashOnURICapture UpsertUpstreamRequestBodyHashOn = "uri_capture"
	UpsertUpstreamRequestBodyHashOnPath       UpsertUpstreamRequestBodyHashOn = "path"
	UpsertUpstreamRequestBodyHashOnQueryArg   UpsertUpstreamRequestBodyHashOn = "query_arg"
)

func (e UpsertUpstreamRequestBodyHashOn) ToPointer() *UpsertUpstreamRequestBodyHashOn {
	return &e
}

func (e *UpsertUpstreamRequestBodyHashOn) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "consumer":
		fallthrough
	case "ip":
		fallthrough
	case "cookie":
		fallthrough
	case "uri_capture":
		fallthrough
	case "path":
		fallthrough
	case "query_arg":
		*e = UpsertUpstreamRequestBodyHashOn(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertUpstreamRequestBodyHashOn: %v", v)
	}
}

type UpsertUpstreamRequestBodyHealthchecksActiveHealthy struct {
	// An array of HTTP statuses to consider a success, indicating healthiness, when returned by a probe in active health checks. With form-encoded, the notation is `http_statuses[]=200&http_statuses[]=302`. With JSON, use an array.
	HTTPStatuses []int64 `json:"http_statuses,omitempty"`
	// Interval between active health checks for healthy targets (in seconds). A value of zero indicates that active probes for healthy targets should not be performed.
	Interval *int64 `json:"interval,omitempty"`
	// Number of successes in active probes (as defined by `healthchecks.active.healthy.http_statuses`) to consider a target healthy.
	Successes *int64 `json:"successes,omitempty"`
}

// UpsertUpstreamRequestBodyHealthchecksActiveType - Whether to perform active health checks using HTTP or HTTPS, or just attempt a TCP connection.
type UpsertUpstreamRequestBodyHealthchecksActiveType string

const (
	UpsertUpstreamRequestBodyHealthchecksActiveTypeTCP   UpsertUpstreamRequestBodyHealthchecksActiveType = "tcp"
	UpsertUpstreamRequestBodyHealthchecksActiveTypeHTTP  UpsertUpstreamRequestBodyHealthchecksActiveType = "http"
	UpsertUpstreamRequestBodyHealthchecksActiveTypeHTTPS UpsertUpstreamRequestBodyHealthchecksActiveType = "https"
	UpsertUpstreamRequestBodyHealthchecksActiveTypeGrpc  UpsertUpstreamRequestBodyHealthchecksActiveType = "grpc"
	UpsertUpstreamRequestBodyHealthchecksActiveTypeGrpcs UpsertUpstreamRequestBodyHealthchecksActiveType = "grpcs"
)

func (e UpsertUpstreamRequestBodyHealthchecksActiveType) ToPointer() *UpsertUpstreamRequestBodyHealthchecksActiveType {
	return &e
}

func (e *UpsertUpstreamRequestBodyHealthchecksActiveType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "grpc":
		fallthrough
	case "grpcs":
		*e = UpsertUpstreamRequestBodyHealthchecksActiveType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertUpstreamRequestBodyHealthchecksActiveType: %v", v)
	}
}

type UpsertUpstreamRequestBodyHealthchecksActiveUnhealthy struct {
	// Number of HTTP failures in active probes (as defined by `healthchecks.active.unhealthy.http_statuses`) to consider a target unhealthy.
	HTTPFailures *int64 `json:"http_failures,omitempty"`
	// An array of HTTP statuses to consider a failure, indicating unhealthiness, when returned by a probe in active health checks. With form-encoded, the notation is `http_statuses[]=429&http_statuses[]=404`. With JSON, use an array.
	HTTPStatuses []int64 `json:"http_statuses,omitempty"`
	// Interval between active health checks for unhealthy targets (in seconds). A value of zero indicates that active probes for unhealthy targets should not be performed.
	Interval *int64 `json:"interval,omitempty"`
	// Number of TCP failures in active probes to consider a target unhealthy.
	TCPFailures *int64 `json:"tcp_failures,omitempty"`
	// Number of timeouts in active probes to consider a target unhealthy.
	Timeouts *int64 `json:"timeouts,omitempty"`
}

type UpsertUpstreamRequestBodyHealthchecksActive struct {
	// Number of targets to check concurrently in active health checks.
	Concurrency *int64                                              `json:"concurrency,omitempty"`
	Healthy     *UpsertUpstreamRequestBodyHealthchecksActiveHealthy `json:"healthy,omitempty"`
	// Path to use in GET HTTP request to run as a probe on active health checks.
	HTTPPath *string `json:"http_path,omitempty"`
	// The hostname to use as an SNI (Server Name Identification) when performing active health checks using HTTPS. This is particularly useful when Targets are configured using IPs, so that the target host’s certificate can be verified with the proper SNI.
	HTTPSSni               *string `json:"https_sni,omitempty"`
	HTTPSVerifyCertificate *bool   `json:"https_verify_certificate,omitempty"`
	// Socket timeout for active health checks (in seconds).
	Timeout *int64 `json:"timeout,omitempty"`
	// Whether to perform active health checks using HTTP or HTTPS, or just attempt a TCP connection.
	Type      *UpsertUpstreamRequestBodyHealthchecksActiveType      `json:"type,omitempty"`
	Unhealthy *UpsertUpstreamRequestBodyHealthchecksActiveUnhealthy `json:"unhealthy,omitempty"`
}

type UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses int64

const (
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundred             UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 200
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndOne       UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 201
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndTwo       UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 202
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndThree     UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 203
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndFour      UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 204
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndFive      UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 205
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndSix       UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 206
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndSeven     UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 207
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndEight     UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 208
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesTwoHundredAndTwentySix UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 226
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundred           UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 300
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndOne     UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 301
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndTwo     UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 302
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndThree   UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 303
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndFour    UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 304
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndFive    UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 305
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndSix     UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 306
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndSeven   UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 307
	UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatusesThreeHundredAndEight   UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses = 308
)

func (e UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses) ToPointer() *UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses {
	return &e
}

func (e *UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 200:
		fallthrough
	case 201:
		fallthrough
	case 202:
		fallthrough
	case 203:
		fallthrough
	case 204:
		fallthrough
	case 205:
		fallthrough
	case 206:
		fallthrough
	case 207:
		fallthrough
	case 208:
		fallthrough
	case 226:
		fallthrough
	case 300:
		fallthrough
	case 301:
		fallthrough
	case 302:
		fallthrough
	case 303:
		fallthrough
	case 304:
		fallthrough
	case 305:
		fallthrough
	case 306:
		fallthrough
	case 307:
		fallthrough
	case 308:
		*e = UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses: %v", v)
	}
}

type UpsertUpstreamRequestBodyHealthchecksPassiveHealthy struct {
	// An array of HTTP statuses which represent healthiness when produced by proxied traffic, as observed by passive health checks.  With form-encoded, the notation is `http_statuses[]=200&http_statuses[]=201`. With JSON, use an array.
	HTTPStatuses []UpsertUpstreamRequestBodyHealthchecksPassiveHealthyHTTPStatuses `json:"http_statuses,omitempty"`
	// Number of successes in proxied traffic (as defined by `healthchecks.passive.healthy.http_statuses`) to consider a target healthy, as observed by passive health checks.
	Successes *int64 `json:"successes,omitempty"`
}

// UpsertUpstreamRequestBodyHealthchecksPassiveType - Whether to perform passive health checks interpreting HTTP/HTTPS statuses, or just check for TCP connection success. In passive checks, http and https options are equivalent. Accepted values are: `tcp`, `http`, `https`, `grpc`, `grpcs`.
type UpsertUpstreamRequestBodyHealthchecksPassiveType string

const (
	UpsertUpstreamRequestBodyHealthchecksPassiveTypeTCP   UpsertUpstreamRequestBodyHealthchecksPassiveType = "tcp"
	UpsertUpstreamRequestBodyHealthchecksPassiveTypeHTTP  UpsertUpstreamRequestBodyHealthchecksPassiveType = "http"
	UpsertUpstreamRequestBodyHealthchecksPassiveTypeHTTPS UpsertUpstreamRequestBodyHealthchecksPassiveType = "https"
	UpsertUpstreamRequestBodyHealthchecksPassiveTypeGrpc  UpsertUpstreamRequestBodyHealthchecksPassiveType = "grpc"
	UpsertUpstreamRequestBodyHealthchecksPassiveTypeGrpcs UpsertUpstreamRequestBodyHealthchecksPassiveType = "grpcs"
)

func (e UpsertUpstreamRequestBodyHealthchecksPassiveType) ToPointer() *UpsertUpstreamRequestBodyHealthchecksPassiveType {
	return &e
}

func (e *UpsertUpstreamRequestBodyHealthchecksPassiveType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "grpc":
		fallthrough
	case "grpcs":
		*e = UpsertUpstreamRequestBodyHealthchecksPassiveType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertUpstreamRequestBodyHealthchecksPassiveType: %v", v)
	}
}

type UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses int64

const (
	UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatusesFourHundredAndTwentyNine UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses = 429
	UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatusesFiveHundred              UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses = 500
	UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatusesFiveHundredAndThree      UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses = 503
)

func (e UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses) ToPointer() *UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses {
	return &e
}

func (e *UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 429:
		fallthrough
	case 500:
		fallthrough
	case 503:
		*e = UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses: %v", v)
	}
}

type UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthy struct {
	// Number of HTTP failures in proxied traffic (as defined by `healthchecks.passive.unhealthy.http_statuses`) to consider a target unhealthy, as observed by passive health checks.
	HTTPFailures *int64 `json:"http_failures,omitempty"`
	// An array of HTTP statuses which represent unhealthiness when produced by proxied traffic, as observed by passive health checks. With form-encoded, the notation is `http_statuses[]=429&http_statuses[]=500`. With JSON, use an array.
	HTTPStatuses []UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthyHTTPStatuses `json:"http_statuses,omitempty"`
	// Number of TCP connection failures to consider a target unhealthy, as observed by passive health checks.
	TCPFailures *int64 `json:"tcp_failures,omitempty"`
	// Number of timeouts in proxied traffic to consider a target unhealthy, as observed by passive health checks.
	Timeouts *int64 `json:"timeouts,omitempty"`
}

type UpsertUpstreamRequestBodyHealthchecksPassive struct {
	Healthy *UpsertUpstreamRequestBodyHealthchecksPassiveHealthy `json:"healthy,omitempty"`
	// Whether to perform passive health checks interpreting HTTP/HTTPS statuses, or just check for TCP connection success. In passive checks, http and https options are equivalent. Accepted values are: `tcp`, `http`, `https`, `grpc`, `grpcs`.
	Type      *UpsertUpstreamRequestBodyHealthchecksPassiveType      `json:"type,omitempty"`
	Unhealthy *UpsertUpstreamRequestBodyHealthchecksPassiveUnhealthy `json:"unhealthy,omitempty"`
}

type UpsertUpstreamRequestBodyHealthchecks struct {
	Active  *UpsertUpstreamRequestBodyHealthchecksActive  `json:"active,omitempty"`
	Passive *UpsertUpstreamRequestBodyHealthchecksPassive `json:"passive,omitempty"`
	// The minimum percentage of the upstream’s targets’ weight that must be available for the whole upstream to be considered healthy.
	Threshold *int64 `json:"threshold,omitempty"`
}

type UpsertUpstreamRequestBody struct {
	// Which load balancing algorithm to use. Accepted values are: `consistent-hashing`, `least-connections`,` round-robin`. Default: `round-robin`.
	//
	Algorithm *UpsertUpstreamRequestBodyAlgorithm `json:"algorithm,omitempty"`
	// If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
	ClientCertificate *UpsertUpstreamRequestBodyClientCertificate `json:"client_certificate,omitempty"`
	// What to use as hashing input if the primary hash_on does not return a hash (eg. header is missing, or no Consumer identified). Not available if hash_on is set to cookie.
	HashFallback *UpsertUpstreamRequestBodyHashFallback `json:"hash_fallback,omitempty"`
	// The header name to take the value from as hash input. Only required when hash_fallback is set to header.
	HashFallbackHeader *string `json:"hash_fallback_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
	HashFallbackQueryArg *string `json:"hash_fallback_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
	HashFallbackURICapture *string `json:"hash_fallback_uri_capture,omitempty"`
	// What to use as hashing input. Using none results in a weighted-round-robin scheme with no hashing
	HashOn *UpsertUpstreamRequestBodyHashOn `json:"hash_on,omitempty"`
	// The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
	HashOnCookie *string `json:"hash_on_cookie,omitempty"`
	// The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`. Default: `/`.
	HashOnCookiePath *string `json:"hash_on_cookie_path,omitempty"`
	// The header name to take the value from as hash input. Only required when `hash_on` is set to header.
	HashOnHeader *string `json:"hash_on_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
	HashOnQueryArg *string `json:"hash_on_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
	HashOnURICapture *string                                `json:"hash_on_uri_capture,omitempty"`
	Healthchecks     *UpsertUpstreamRequestBodyHealthchecks `json:"healthchecks,omitempty"`
	// The hostname to be used as Host header when proxying requests through Kong.
	HostHeader *string `json:"host_header,omitempty"`
	// This is a hostname, which must be equal to the `host` of a service.
	Name string `json:"name"`
	// The number of slots in the load balancer algorithm. If the algorithm is set to `round-robin`, this setting determines the maximum number of slots. If the algorithm is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range 10-65536.
	Slots *int64 `json:"slots,omitempty"`
	// An optional set of strings associated with the Upstream for grouping and filtering.
	Tags []string `json:"tags,omitempty"`
}

type UpsertUpstreamRequest struct {
	RequestBody *UpsertUpstreamRequestBody `request:"mediaType=application/json"`
	// The ID of your runtime group. This variable is available in the Konnect manager
	RuntimeGroupID string `pathParam:"style=simple,explode=false,name=runtimeGroupId"`
	// The unique identifier of the Upstream associated to the Certificate to be retrieved.
	UpstreamID string `pathParam:"style=simple,explode=false,name=upstream_id"`
}

// UpsertUpstream400ApplicationJSON - Invalid Upstream
type UpsertUpstream400ApplicationJSON struct {
}

type UpsertUpstreamResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successfully upserted Upstream
	Upstream *shared.Upstream
	// Invalid Upstream
	UpsertUpstream400ApplicationJSONObject *UpsertUpstream400ApplicationJSON
}

// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"Konnect/internal/sdk/pkg/models/shared"
	"encoding/json"
	"fmt"
	"net/http"
)

type UpsertRouteForServiceRequestBodyDestinations struct {
	IP   *string `json:"ip,omitempty"`
	Port *int64  `json:"port,omitempty"`
}

// UpsertRouteForServiceRequestBodyHeaders - One or more lists of values indexed by header name that will cause this route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When headers contains only one value and that value starts with the special prefix` ~*`, the value is interpreted as a regular expression.
type UpsertRouteForServiceRequestBodyHeaders struct {
	XAnotherHeader []string `json:"x-another-header,omitempty"`
	XMyHeader      []string `json:"x-my-header,omitempty"`
}

// UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode - The status code Kong responds with when all properties of a route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`
// Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Note: This config applies only if the route is configured to only accept the https protocol. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
type UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode int64

const (
	UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCodeFourHundredAndTwentySix UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode = 426
	UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCodeThreeHundredAndOne      UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode = 301
	UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCodeThreeHundredAndTwo      UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode = 302
	UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCodeThreeHundredAndSeven    UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode = 307
	UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCodeThreeHundredAndEight    UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode = 308
)

func (e UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode) ToPointer() *UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode {
	return &e
}

func (e *UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 426:
		fallthrough
	case 301:
		fallthrough
	case 302:
		fallthrough
	case 307:
		fallthrough
	case 308:
		*e = UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode: %v", v)
	}
}

// UpsertRouteForServiceRequestBodyPathHandling - Controls how the service path, route path and requested path are combined when sending a request to the upstream. Accepted values are: `v0`, `v1`. Default: `v0`.
type UpsertRouteForServiceRequestBodyPathHandling string

const (
	UpsertRouteForServiceRequestBodyPathHandlingV1 UpsertRouteForServiceRequestBodyPathHandling = "v1"
	UpsertRouteForServiceRequestBodyPathHandlingV0 UpsertRouteForServiceRequestBodyPathHandling = "v0"
)

func (e UpsertRouteForServiceRequestBodyPathHandling) ToPointer() *UpsertRouteForServiceRequestBodyPathHandling {
	return &e
}

func (e *UpsertRouteForServiceRequestBodyPathHandling) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v1":
		fallthrough
	case "v0":
		*e = UpsertRouteForServiceRequestBodyPathHandling(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpsertRouteForServiceRequestBodyPathHandling: %v", v)
	}
}

// UpsertRouteForServiceRequestBodyService - The service this route is associated to. This is where the route proxies traffic to. With form-encoded, the notation is service.id=<service id> or service.name=<service name>. With JSON, use “`service:{id:<service id>}` or `service:{name:<service name>}`.
type UpsertRouteForServiceRequestBodyService struct {
	ID *string `json:"id,omitempty"`
}

type UpsertRouteForServiceRequestBodySources struct {
	IP   *string `json:"ip,omitempty"`
	Port *int64  `json:"port,omitempty"`
}

// UpsertRouteForServiceRequestBody - Route request body
type UpsertRouteForServiceRequestBody struct {
	// A list of IP destinations of incoming connections that match this route when using stream routing. Each entry is an object with fields “ip” (optionally in CIDR range notation) and/or “port”.
	//
	Destinations []UpsertRouteForServiceRequestBodyDestinations `json:"destinations,omitempty"`
	// One or more lists of values indexed by header name that will cause this route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When headers contains only one value and that value starts with the special prefix` ~*`, the value is interpreted as a regular expression.
	Headers *UpsertRouteForServiceRequestBodyHeaders `json:"headers,omitempty"`
	// A list of domain names that match this route. Note that the hosts value is case sensitive. With form-encoded, the notation is `hosts[]=example.com&hosts[]=foo.test`. With JSON, use an Array.
	Hosts []string `json:"hosts,omitempty"`
	// The status code Kong responds with when all properties of a route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`
	// Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Note: This config applies only if the route is configured to only accept the https protocol. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
	HTTPSRedirectStatusCode UpsertRouteForServiceRequestBodyHTTPSRedirectStatusCode `json:"https_redirect_status_code"`
	// A list of HTTP methods that match this route.
	//
	Methods []string `json:"methods,omitempty"`
	// The name of the route. Route names must be unique, and they are case sensitive. For example, there can be two different routes named “test” and “Test”.
	//
	Name *string `json:"name,omitempty"`
	// Controls how the service path, route path and requested path are combined when sending a request to the upstream. Accepted values are: `v0`, `v1`. Default: `v0`.
	PathHandling *UpsertRouteForServiceRequestBodyPathHandling `json:"path_handling,omitempty"`
	// A list of paths that match this route. With form-encoded, the notation is `paths[]=/foo&paths[]=/bar`. With JSON, use an array. The path can be a regular expression, or a plain text pattern.
	Paths []string `json:"paths,omitempty"`
	// When matching a route via one of the `hosts` domain names, use the request `host` header in the upstream request headers. If set to `false`, the upstream Host header will be that of the service’s host.
	PreserveHost bool `json:"preserve_host"`
	// An array of the protocols this route should allow
	Protocols []string `json:"protocols"`
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same regex_priority, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones). Default: `0`.
	RegexPriority *int64 `json:"regex_priority,omitempty"`
	// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
	//
	RequestBuffering bool `json:"request_buffering"`
	// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: `true`.
	//
	ResponseBuffering bool `json:"response_buffering"`
	// The service this route is associated to. This is where the route proxies traffic to. With form-encoded, the notation is service.id=<service id> or service.name=<service name>. With JSON, use “`service:{id:<service id>}` or `service:{name:<service name>}`.
	Service *UpsertRouteForServiceRequestBodyService `json:"service,omitempty"`
	// A list of SNIs that match this route when using stream routing.
	//
	Snis []string `json:"snis,omitempty"`
	// A list of IP sources of incoming connections that match this route when using stream routing. Each entry is an object with fields “ip” (optionally in CIDR range notation) and/or “port”.
	//
	Sources []UpsertRouteForServiceRequestBodySources `json:"sources,omitempty"`
	// When matching a route via one of the paths, strip the matching prefix from the upstream request URL. Default: `true`.
	StripPath *bool `json:"strip_path,omitempty"`
	// An optional set of strings associated with the route for grouping and filtering.
	//
	Tags []string `json:"tags,omitempty"`
}

type UpsertRouteForServiceRequest struct {
	// Route request body
	RequestBody *UpsertRouteForServiceRequestBody `request:"mediaType=application/json"`
	// The unique identifier or the name of the route to retrieve.
	RouteID string `pathParam:"style=simple,explode=false,name=route_id"`
	// The ID of your runtime group. This variable is available in the Konnect manager
	RuntimeGroupID string `pathParam:"style=simple,explode=false,name=runtimeGroupId"`
	// ID **or** name of the service to lookup
	ServiceID string `pathParam:"style=simple,explode=false,name=service_id"`
}

// UpsertRouteForService400ApplicationJSON - Invalid route
type UpsertRouteForService400ApplicationJSON struct {
}

type UpsertRouteForServiceResponse struct {
	ContentType string
	// Successfully upserted route
	Route       *shared.Route
	StatusCode  int
	RawResponse *http.Response
	// Invalid route
	UpsertRouteForService400ApplicationJSONObject *UpsertRouteForService400ApplicationJSON
}

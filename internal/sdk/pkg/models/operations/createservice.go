// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// CreateServiceRequestBodyClientCertificate - Certificate to be used as client certificate while TLS handshaking to the upstream server. With form-encoded, the notation is `client_certificate.id=<client_certificate id>`. With JSON, use `client_certificate:{id:<client_certificate id>}`.
type CreateServiceRequestBodyClientCertificate struct {
	ID *string `json:"id,omitempty"`
}

// CreateServiceRequestBodyProtocol - The protocol used to communicate with the upstream. Accepted values are: `grpc`, `grpcs`, `http`, `https`, `tcp`, `tls`, `tls_passthrough`, `udp`, `ws`
// , `wss`
// . Default: `http`.
type CreateServiceRequestBodyProtocol string

const (
	CreateServiceRequestBodyProtocolGrpc           CreateServiceRequestBodyProtocol = "grpc"
	CreateServiceRequestBodyProtocolGrpcs          CreateServiceRequestBodyProtocol = "grpcs"
	CreateServiceRequestBodyProtocolHTTP           CreateServiceRequestBodyProtocol = "http"
	CreateServiceRequestBodyProtocolHTTPS          CreateServiceRequestBodyProtocol = "https"
	CreateServiceRequestBodyProtocolTCP            CreateServiceRequestBodyProtocol = "tcp"
	CreateServiceRequestBodyProtocolTLS            CreateServiceRequestBodyProtocol = "tls "
	CreateServiceRequestBodyProtocolTLSPassthrough CreateServiceRequestBodyProtocol = "tls_passthrough"
	CreateServiceRequestBodyProtocolUDP            CreateServiceRequestBodyProtocol = "udp"
	CreateServiceRequestBodyProtocolWs             CreateServiceRequestBodyProtocol = "ws"
	CreateServiceRequestBodyProtocolWss            CreateServiceRequestBodyProtocol = "wss"
)

func (e CreateServiceRequestBodyProtocol) ToPointer() *CreateServiceRequestBodyProtocol {
	return &e
}

func (e *CreateServiceRequestBodyProtocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grpc":
		fallthrough
	case "grpcs":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "tcp":
		fallthrough
	case "tls ":
		fallthrough
	case "tls_passthrough":
		fallthrough
	case "udp":
		fallthrough
	case "ws":
		fallthrough
	case "wss":
		*e = CreateServiceRequestBodyProtocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateServiceRequestBodyProtocol: %v", v)
	}
}

type CreateServiceRequestBody struct {
	// Array of CA Certificate object UUIDs that are used to build the trust store while verifying upstream server’s TLS certificate. If set to null when Nginx default is respected. With form-encoded, the notation is `ca_certificates[]=4e3ad2e4-0bc4-4638-8e34-c84a417ba39b&ca_certificates[]=51e77dc2-8f3e-4afa-9d0e-0e3bbbcfd515`. With JSON, use an Array.
	CaCertificates []string `json:"ca_certificates,omitempty"`
	// Certificate to be used as client certificate while TLS handshaking to the upstream server. With form-encoded, the notation is `client_certificate.id=<client_certificate id>`. With JSON, use `client_certificate:{id:<client_certificate id>}`.
	ClientCertificate *CreateServiceRequestBodyClientCertificate `json:"client_certificate,omitempty"`
	// The timeout in milliseconds for establishing a connection to the upstream server. Default: `60000`.
	ConnectTimeout *int64 `json:"connect_timeout,omitempty"`
	// Whether the service is active. If set to `false`, the proxy behavior will be as if any routes attached to it do not exist (404). Default: `true`.
	Enabled bool `json:"enabled"`
	// The host of the upstream server. Note that the host value is case sensitive.
	//
	Host string `json:"host"`
	// The service name.
	//
	Name *string `json:"name,omitempty"`
	// The path to be used in requests to the upstream server.
	//
	Path *string `json:"path,omitempty"`
	// The upstream server port. Default: `80`.
	//
	Port int64 `json:"port"`
	// The protocol used to communicate with the upstream. Accepted values are: `grpc`, `grpcs`, `http`, `https`, `tcp`, `tls`, `tls_passthrough`, `udp`, `ws`
	// , `wss`
	// . Default: `http`.
	Protocol CreateServiceRequestBodyProtocol `json:"protocol"`
	// The timeout in milliseconds between two successive read operations for transmitting a request to the upstream server. Default: `60000`.
	//
	ReadTimeout *int64 `json:"read_timeout,omitempty"`
	// The number of retries to execute upon failure to proxy. Default:`5`.
	//
	Retries *int64 `json:"retries,omitempty"`
	// An optional set of strings associated with the service for grouping and filtering.
	//
	Tags []string `json:"tags,omitempty"`
	// Whether to enable verification of upstream server TLS certificate. If set to null, then the Nginx default is respected.
	//
	TLSVerify *bool `json:"tls_verify,omitempty"`
	// Maximum depth of chain while verifying Upstream server’s TLS certificate. If set to null, then the Nginx default is respected. Default: null.
	//
	TLSVerifyDepth *string `json:"tls_verify_depth,omitempty"`
	// The timeout in milliseconds between two successive write operations for transmitting a request to the upstream server. Default: `60000`.
	//
	WriteTimeout *int64 `json:"write_timeout,omitempty"`
}

type CreateServiceRequest struct {
	RequestBody *CreateServiceRequestBody `request:"mediaType=application/json"`
	// The ID of your runtime group. This variable is available in the Konnect manager
	RuntimeGroupID string `pathParam:"style=simple,explode=false,name=runtimeGroupId"`
}

// CreateService400ApplicationJSON - Invalid service
type CreateService400ApplicationJSON struct {
}

// CreateService201ApplicationJSON - Successfully created service
type CreateService201ApplicationJSON struct {
	ConnectTimeout *int64  `json:"connect_timeout,omitempty"`
	CreatedAt      *int64  `json:"created_at,omitempty"`
	Enabled        *bool   `json:"enabled,omitempty"`
	Host           *string `json:"host,omitempty"`
	ID             *string `json:"id,omitempty"`
	Name           *string `json:"name,omitempty"`
	Path           *string `json:"path,omitempty"`
	Port           *int64  `json:"port,omitempty"`
	Protocol       *string `json:"protocol,omitempty"`
	ReadTimeout    *int64  `json:"read_timeout,omitempty"`
	Retries        *int64  `json:"retries,omitempty"`
	UpdatedAt      *int64  `json:"updated_at,omitempty"`
	WriteTimeout   *int64  `json:"write_timeout,omitempty"`
}

type CreateServiceResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successfully created service
	CreateService201ApplicationJSONObject *CreateService201ApplicationJSON
	// Invalid service
	CreateService400ApplicationJSONObject *CreateService400ApplicationJSON
}

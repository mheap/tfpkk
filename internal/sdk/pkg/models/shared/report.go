// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"time"
)

// ReportChartType - Visualization type selected for this report.
type ReportChartType string

const (
	ReportChartTypeHorizontalBar ReportChartType = "HORIZONTAL_BAR"
	ReportChartTypeVerticalBar   ReportChartType = "VERTICAL_BAR"
	ReportChartTypeLine          ReportChartType = "LINE"
)

func (e ReportChartType) ToPointer() *ReportChartType {
	return &e
}

func (e *ReportChartType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HORIZONTAL_BAR":
		fallthrough
	case "VERTICAL_BAR":
		fallthrough
	case "LINE":
		*e = ReportChartType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReportChartType: %v", v)
	}
}

type ReportQueryDimensions string

const (
	ReportQueryDimensionsAPIProduct        ReportQueryDimensions = "API_PRODUCT"
	ReportQueryDimensionsAPIProductVersion ReportQueryDimensions = "API_PRODUCT_VERSION"
	ReportQueryDimensionsRoute             ReportQueryDimensions = "ROUTE"
	ReportQueryDimensionsApplication       ReportQueryDimensions = "APPLICATION"
	ReportQueryDimensionsStatusCode        ReportQueryDimensions = "STATUS_CODE"
	ReportQueryDimensionsStatusCodeGrouped ReportQueryDimensions = "STATUS_CODE_GROUPED"
	ReportQueryDimensionsGatewayService    ReportQueryDimensions = "GATEWAY_SERVICE"
	ReportQueryDimensionsRuntimeGroup      ReportQueryDimensions = "RUNTIME_GROUP"
	ReportQueryDimensionsTime              ReportQueryDimensions = "TIME"
)

func (e ReportQueryDimensions) ToPointer() *ReportQueryDimensions {
	return &e
}

func (e *ReportQueryDimensions) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "API_PRODUCT":
		fallthrough
	case "API_PRODUCT_VERSION":
		fallthrough
	case "ROUTE":
		fallthrough
	case "APPLICATION":
		fallthrough
	case "STATUS_CODE":
		fallthrough
	case "STATUS_CODE_GROUPED":
		fallthrough
	case "GATEWAY_SERVICE":
		fallthrough
	case "RUNTIME_GROUP":
		fallthrough
	case "TIME":
		*e = ReportQueryDimensions(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReportQueryDimensions: %v", v)
	}
}

type ReportQueryFilterType string

const (
	ReportQueryFilterTypeAPIProductFilter        ReportQueryFilterType = "ApiProductFilter"
	ReportQueryFilterTypeAPIProductVersionFilter ReportQueryFilterType = "ApiProductVersionFilter"
	ReportQueryFilterTypeRouteFilter             ReportQueryFilterType = "RouteFilter"
	ReportQueryFilterTypeApplicationFilter       ReportQueryFilterType = "ApplicationFilter"
	ReportQueryFilterTypeStatusCodeFilter        ReportQueryFilterType = "StatusCodeFilter"
	ReportQueryFilterTypeStatusCodeGroupedFilter ReportQueryFilterType = "StatusCodeGroupedFilter"
	ReportQueryFilterTypeGatewayServiceFilter    ReportQueryFilterType = "GatewayServiceFilter"
	ReportQueryFilterTypeRuntimeGroupFilter      ReportQueryFilterType = "RuntimeGroupFilter"
)

type ReportQueryFilter struct {
	APIProductFilter        *APIProductFilter
	APIProductVersionFilter *APIProductVersionFilter
	RouteFilter             *RouteFilter
	ApplicationFilter       *ApplicationFilter
	StatusCodeFilter        *StatusCodeFilter
	StatusCodeGroupedFilter *StatusCodeGroupedFilter
	GatewayServiceFilter    *GatewayServiceFilter
	RuntimeGroupFilter      *RuntimeGroupFilter

	Type ReportQueryFilterType
}

func CreateReportQueryFilterAPIProductFilter(apiProductFilter APIProductFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeAPIProductFilter

	return ReportQueryFilter{
		APIProductFilter: &apiProductFilter,
		Type:             typ,
	}
}

func CreateReportQueryFilterAPIProductVersionFilter(apiProductVersionFilter APIProductVersionFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeAPIProductVersionFilter

	return ReportQueryFilter{
		APIProductVersionFilter: &apiProductVersionFilter,
		Type:                    typ,
	}
}

func CreateReportQueryFilterRouteFilter(routeFilter RouteFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeRouteFilter

	return ReportQueryFilter{
		RouteFilter: &routeFilter,
		Type:        typ,
	}
}

func CreateReportQueryFilterApplicationFilter(applicationFilter ApplicationFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeApplicationFilter

	return ReportQueryFilter{
		ApplicationFilter: &applicationFilter,
		Type:              typ,
	}
}

func CreateReportQueryFilterStatusCodeFilter(statusCodeFilter StatusCodeFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeStatusCodeFilter

	return ReportQueryFilter{
		StatusCodeFilter: &statusCodeFilter,
		Type:             typ,
	}
}

func CreateReportQueryFilterStatusCodeGroupedFilter(statusCodeGroupedFilter StatusCodeGroupedFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeStatusCodeGroupedFilter

	return ReportQueryFilter{
		StatusCodeGroupedFilter: &statusCodeGroupedFilter,
		Type:                    typ,
	}
}

func CreateReportQueryFilterGatewayServiceFilter(gatewayServiceFilter GatewayServiceFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeGatewayServiceFilter

	return ReportQueryFilter{
		GatewayServiceFilter: &gatewayServiceFilter,
		Type:                 typ,
	}
}

func CreateReportQueryFilterRuntimeGroupFilter(runtimeGroupFilter RuntimeGroupFilter) ReportQueryFilter {
	typ := ReportQueryFilterTypeRuntimeGroupFilter

	return ReportQueryFilter{
		RuntimeGroupFilter: &runtimeGroupFilter,
		Type:               typ,
	}
}

func (u *ReportQueryFilter) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	apiProductFilter := new(APIProductFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&apiProductFilter); err == nil {
		u.APIProductFilter = apiProductFilter
		u.Type = ReportQueryFilterTypeAPIProductFilter
		return nil
	}

	apiProductVersionFilter := new(APIProductVersionFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&apiProductVersionFilter); err == nil {
		u.APIProductVersionFilter = apiProductVersionFilter
		u.Type = ReportQueryFilterTypeAPIProductVersionFilter
		return nil
	}

	routeFilter := new(RouteFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&routeFilter); err == nil {
		u.RouteFilter = routeFilter
		u.Type = ReportQueryFilterTypeRouteFilter
		return nil
	}

	applicationFilter := new(ApplicationFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&applicationFilter); err == nil {
		u.ApplicationFilter = applicationFilter
		u.Type = ReportQueryFilterTypeApplicationFilter
		return nil
	}

	statusCodeFilter := new(StatusCodeFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&statusCodeFilter); err == nil {
		u.StatusCodeFilter = statusCodeFilter
		u.Type = ReportQueryFilterTypeStatusCodeFilter
		return nil
	}

	statusCodeGroupedFilter := new(StatusCodeGroupedFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&statusCodeGroupedFilter); err == nil {
		u.StatusCodeGroupedFilter = statusCodeGroupedFilter
		u.Type = ReportQueryFilterTypeStatusCodeGroupedFilter
		return nil
	}

	gatewayServiceFilter := new(GatewayServiceFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&gatewayServiceFilter); err == nil {
		u.GatewayServiceFilter = gatewayServiceFilter
		u.Type = ReportQueryFilterTypeGatewayServiceFilter
		return nil
	}

	runtimeGroupFilter := new(RuntimeGroupFilter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&runtimeGroupFilter); err == nil {
		u.RuntimeGroupFilter = runtimeGroupFilter
		u.Type = ReportQueryFilterTypeRuntimeGroupFilter
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ReportQueryFilter) MarshalJSON() ([]byte, error) {
	if u.APIProductFilter != nil {
		return json.Marshal(u.APIProductFilter)
	}

	if u.APIProductVersionFilter != nil {
		return json.Marshal(u.APIProductVersionFilter)
	}

	if u.RouteFilter != nil {
		return json.Marshal(u.RouteFilter)
	}

	if u.ApplicationFilter != nil {
		return json.Marshal(u.ApplicationFilter)
	}

	if u.StatusCodeFilter != nil {
		return json.Marshal(u.StatusCodeFilter)
	}

	if u.StatusCodeGroupedFilter != nil {
		return json.Marshal(u.StatusCodeGroupedFilter)
	}

	if u.GatewayServiceFilter != nil {
		return json.Marshal(u.GatewayServiceFilter)
	}

	if u.RuntimeGroupFilter != nil {
		return json.Marshal(u.RuntimeGroupFilter)
	}

	return nil, nil
}

// ReportQueryGranularity - `granularity` is only valid for queries that include a time dimension, and it specifies the time buckets for the returned data.  For example, `MINUTELY` granularity will return datapoints for every minute.  Not all granularities are available for all time ranges: for example, custom timeframes only have `DAILY` granularity.
//
// If unspecified, a default value for the given time range will be chosen according to the following table:
//
// - `FIFTEEN_MIN`: `MINUTELY`
// - `ONE_HOUR`: `MINUTELY`
// - `SIX_HOUR`: `HOURLY`
// - `TWELVE_HOUR`: `HOURLY`
// - `ONE_DAY`: `HOURLY`
// - `SEVEN_DAY`: `DAILY`
// - `THIRTY_DAY`: `DAILY`
// - `CURRENT_WEEK`: `DAILY`
// - `CURRENT_MONTH`: `DAILY`
// - `PREVIOUS_WEEK`: `DAILY`
// - `PREVIOUS_MONTH`: `DAILY`
type ReportQueryGranularity string

const (
	ReportQueryGranularityMinutely ReportQueryGranularity = "MINUTELY"
	ReportQueryGranularityHourly   ReportQueryGranularity = "HOURLY"
	ReportQueryGranularityDaily    ReportQueryGranularity = "DAILY"
	ReportQueryGranularityWeekly   ReportQueryGranularity = "WEEKLY"
)

func (e ReportQueryGranularity) ToPointer() *ReportQueryGranularity {
	return &e
}

func (e *ReportQueryGranularity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MINUTELY":
		fallthrough
	case "HOURLY":
		fallthrough
	case "DAILY":
		fallthrough
	case "WEEKLY":
		*e = ReportQueryGranularity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReportQueryGranularity: %v", v)
	}
}

type ReportQueryMetrics string

const (
	ReportQueryMetricsRequestCount       ReportQueryMetrics = "REQUEST_COUNT"
	ReportQueryMetricsRequestPerMinute   ReportQueryMetrics = "REQUEST_PER_MINUTE"
	ReportQueryMetricsResponseLatencyP99 ReportQueryMetrics = "RESPONSE_LATENCY_P99"
	ReportQueryMetricsResponseLatencyP95 ReportQueryMetrics = "RESPONSE_LATENCY_P95"
	ReportQueryMetricsResponseLatencyP50 ReportQueryMetrics = "RESPONSE_LATENCY_P50"
	ReportQueryMetricsResponseSizeP99    ReportQueryMetrics = "RESPONSE_SIZE_P99"
	ReportQueryMetricsResponseSizeP95    ReportQueryMetrics = "RESPONSE_SIZE_P95"
	ReportQueryMetricsResponseSizeP50    ReportQueryMetrics = "RESPONSE_SIZE_P50"
	ReportQueryMetricsRequestSizeP99     ReportQueryMetrics = "REQUEST_SIZE_P99"
	ReportQueryMetricsRequestSizeP95     ReportQueryMetrics = "REQUEST_SIZE_P95"
	ReportQueryMetricsRequestSizeP50     ReportQueryMetrics = "REQUEST_SIZE_P50"
)

func (e ReportQueryMetrics) ToPointer() *ReportQueryMetrics {
	return &e
}

func (e *ReportQueryMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "REQUEST_COUNT":
		fallthrough
	case "REQUEST_PER_MINUTE":
		fallthrough
	case "RESPONSE_LATENCY_P99":
		fallthrough
	case "RESPONSE_LATENCY_P95":
		fallthrough
	case "RESPONSE_LATENCY_P50":
		fallthrough
	case "RESPONSE_SIZE_P99":
		fallthrough
	case "RESPONSE_SIZE_P95":
		fallthrough
	case "RESPONSE_SIZE_P50":
		fallthrough
	case "REQUEST_SIZE_P99":
		fallthrough
	case "REQUEST_SIZE_P95":
		fallthrough
	case "REQUEST_SIZE_P50":
		*e = ReportQueryMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReportQueryMetrics: %v", v)
	}
}

type ReportQuery struct {
	// The dimensions for the report.  A report may have up to 2 dimensions, including time.
	// If the report has a timeseries graph, the time dimension will be added automatically if not provided.
	// If no dimensions are provided, the report will simply return the provided metric aggregated across
	// all available data.
	//
	Dimensions []ReportQueryDimensions `json:"dimensions,omitempty"`
	Filter     []ReportQueryFilter     `json:"filter,omitempty"`
	// `granularity` is only valid for queries that include a time dimension, and it specifies the time buckets for the returned data.  For example, `MINUTELY` granularity will return datapoints for every minute.  Not all granularities are available for all time ranges: for example, custom timeframes only have `DAILY` granularity.
	//
	// If unspecified, a default value for the given time range will be chosen according to the following table:
	//
	// - `FIFTEEN_MIN`: `MINUTELY`
	// - `ONE_HOUR`: `MINUTELY`
	// - `SIX_HOUR`: `HOURLY`
	// - `TWELVE_HOUR`: `HOURLY`
	// - `ONE_DAY`: `HOURLY`
	// - `SEVEN_DAY`: `DAILY`
	// - `THIRTY_DAY`: `DAILY`
	// - `CURRENT_WEEK`: `DAILY`
	// - `CURRENT_MONTH`: `DAILY`
	// - `PREVIOUS_WEEK`: `DAILY`
	// - `PREVIOUS_MONTH`: `DAILY`
	//
	Granularity *ReportQueryGranularity `json:"granularity,omitempty"`
	// A property of your API (such as request count or latency) that you wish to report on.
	// Your chosen metric is aggregated within the specified dimensions, meaning that if you query 'request count by service', you'll receive the total number of requests each service received within the given time frame.  Some metrics, such as latency and response size, have more complicated aggregations: selecting P99 will result in the 99th percentile of the chosen metric.
	//
	Metrics []ReportQueryMetrics `json:"metrics,omitempty"`
}

// ReportInput - The request schema for the create report request.
//
// If you pass the same `name` and `description` of an existing report in the request, a report with the same `name` and `description` will be created. The two reports will have different `id` values to differentiate them.
//
// Note that all fields are optional: if you pass an empty JSON object as the request (`{}`), a new report will be created with a default configuration.
type ReportInput struct {
	// Visualization type selected for this report.
	ChartType *ReportChartType `json:"chart_type,omitempty"`
	// An optional extended description for the report.
	Description *string `json:"description,omitempty"`
	// The user-provided name for the report.
	// If not provided, the report will be named "Untitled Report" with a timestamp suffix.
	//
	Name  *string      `json:"name,omitempty"`
	Query *ReportQuery `json:"query,omitempty"`
	// The period of time to return data.  Relative time ranges are relative to the current moment.  Absolute time ranges specify an unchanging period of time.  If not specified, a default relative timeframe of last 24 hours will be chosen.
	//
	TimeRange *TimeRange `json:"time_range,omitempty"`
}

// Report - A response including a single report.
type Report struct {
	// Visualization type selected for this report.
	ChartType *ReportChartType `json:"chart_type,omitempty"`
	// An ISO-8601 timestamp representing when the report was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The UUID of the Konnect user that created the report.
	CreatedBy *string `json:"created_by,omitempty"`
	// An optional extended description for the report.
	Description *string `json:"description,omitempty"`
	// The ID of the report.
	ID *string `json:"id,omitempty"`
	// The user-provided name for the report.
	// If not provided, the report will be named "Untitled Report" with a timestamp suffix.
	//
	Name  *string      `json:"name,omitempty"`
	Query *ReportQuery `json:"query,omitempty"`
	// The period of time to return data.  Relative time ranges are relative to the current moment.  Absolute time ranges specify an unchanging period of time.  If not specified, a default relative timeframe of last 24 hours will be chosen.
	//
	TimeRange *TimeRange `json:"time_range,omitempty"`
	// An ISO-8601 timestamp representing when the report was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

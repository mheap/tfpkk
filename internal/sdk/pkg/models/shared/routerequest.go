// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/internal/sdk/pkg/utils"
)

type Destinations struct {
	IP   *string `json:"ip,omitempty"`
	Port *int64  `json:"port,omitempty"`
}

func (o *Destinations) GetIP() *string {
	if o == nil {
		return nil
	}
	return o.IP
}

func (o *Destinations) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// Headers - One or more lists of values indexed by header name that will cause this route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When headers contains only one value and that value starts with the special prefix` ~*`, the value is interpreted as a regular expression.
type Headers struct {
	XAnotherHeader []string `json:"x-another-header,omitempty"`
	XMyHeader      []string `json:"x-my-header,omitempty"`
}

func (o *Headers) GetXAnotherHeader() []string {
	if o == nil {
		return nil
	}
	return o.XAnotherHeader
}

func (o *Headers) GetXMyHeader() []string {
	if o == nil {
		return nil
	}
	return o.XMyHeader
}

// HTTPSRedirectStatusCode - The status code Kong responds with when all properties of a route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`
// Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Note: This config applies only if the route is configured to only accept the https protocol. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
type HTTPSRedirectStatusCode int64

const (
	HTTPSRedirectStatusCodeFourHundredAndTwentySix HTTPSRedirectStatusCode = 426
	HTTPSRedirectStatusCodeThreeHundredAndOne      HTTPSRedirectStatusCode = 301
	HTTPSRedirectStatusCodeThreeHundredAndTwo      HTTPSRedirectStatusCode = 302
	HTTPSRedirectStatusCodeThreeHundredAndSeven    HTTPSRedirectStatusCode = 307
	HTTPSRedirectStatusCodeThreeHundredAndEight    HTTPSRedirectStatusCode = 308
)

func (e HTTPSRedirectStatusCode) ToPointer() *HTTPSRedirectStatusCode {
	return &e
}

func (e *HTTPSRedirectStatusCode) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 426:
		fallthrough
	case 301:
		fallthrough
	case 302:
		fallthrough
	case 307:
		fallthrough
	case 308:
		*e = HTTPSRedirectStatusCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HTTPSRedirectStatusCode: %v", v)
	}
}

// PathHandling - Controls how the service path, route path and requested path are combined when sending a request to the upstream. Accepted values are: `v0`, `v1`. Default: `v0`.
type PathHandling string

const (
	PathHandlingV1 PathHandling = "v1"
	PathHandlingV0 PathHandling = "v0"
)

func (e PathHandling) ToPointer() *PathHandling {
	return &e
}

func (e *PathHandling) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v1":
		fallthrough
	case "v0":
		*e = PathHandling(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PathHandling: %v", v)
	}
}

// RouteRequestService - The service this route is associated to. This is where the route proxies traffic to. With form-encoded, the notation is service.id=<service id> or service.name=<service name>. With JSON, use “`service:{id:<service id>}` or `service:{name:<service name>}`.
type RouteRequestService struct {
	ID *string `json:"id,omitempty"`
}

func (o *RouteRequestService) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

type Sources struct {
	IP   *string `json:"ip,omitempty"`
	Port *int64  `json:"port,omitempty"`
}

func (o *Sources) GetIP() *string {
	if o == nil {
		return nil
	}
	return o.IP
}

func (o *Sources) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type RouteRequest struct {
	// A list of IP destinations of incoming connections that match this route when using stream routing. Each entry is an object with fields “ip” (optionally in CIDR range notation) and/or “port”.
	//
	Destinations []Destinations `json:"destinations,omitempty"`
	// One or more lists of values indexed by header name that will cause this route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When headers contains only one value and that value starts with the special prefix` ~*`, the value is interpreted as a regular expression.
	Headers *Headers `json:"headers,omitempty"`
	// A list of domain names that match this route. Note that the hosts value is case sensitive. With form-encoded, the notation is `hosts[]=example.com&hosts[]=foo.test`. With JSON, use an Array.
	Hosts []string `json:"hosts,omitempty"`
	// The status code Kong responds with when all properties of a route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`
	// Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Note: This config applies only if the route is configured to only accept the https protocol. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
	HTTPSRedirectStatusCode *HTTPSRedirectStatusCode `default:"426" json:"https_redirect_status_code"`
	// A list of HTTP methods that match this route.
	//
	Methods []string `json:"methods,omitempty"`
	// The name of the route. Route names must be unique, and they are case sensitive. For example, there can be two different routes named “test” and “Test”.
	//
	Name *string `json:"name,omitempty"`
	// Controls how the service path, route path and requested path are combined when sending a request to the upstream. Accepted values are: `v0`, `v1`. Default: `v0`.
	PathHandling *PathHandling `json:"path_handling,omitempty"`
	// A list of paths that match this route. With form-encoded, the notation is `paths[]=/foo&paths[]=/bar`. With JSON, use an array. The path can be a regular expression, or a plain text pattern.
	Paths []string `json:"paths,omitempty"`
	// When matching a route via one of the `hosts` domain names, use the request `host` header in the upstream request headers. If set to `false`, the upstream Host header will be that of the service’s host.
	PreserveHost *bool `default:"true" json:"preserve_host"`
	// An array of the protocols this route should allow
	Protocols []string `json:"protocols,omitempty"`
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same regex_priority, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones). Default: `0`.
	RegexPriority *int64 `default:"0" json:"regex_priority"`
	// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
	//
	RequestBuffering *bool `default:"true" json:"request_buffering"`
	// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: `true`.
	//
	ResponseBuffering *bool `default:"true" json:"response_buffering"`
	// The service this route is associated to. This is where the route proxies traffic to. With form-encoded, the notation is service.id=<service id> or service.name=<service name>. With JSON, use “`service:{id:<service id>}` or `service:{name:<service name>}`.
	Service *RouteRequestService `json:"service,omitempty"`
	// A list of SNIs that match this route when using stream routing.
	//
	Snis []string `json:"snis,omitempty"`
	// A list of IP sources of incoming connections that match this route when using stream routing. Each entry is an object with fields “ip” (optionally in CIDR range notation) and/or “port”.
	//
	Sources []Sources `json:"sources,omitempty"`
	// When matching a route via one of the paths, strip the matching prefix from the upstream request URL. Default: `true`.
	StripPath *bool `default:"true" json:"strip_path"`
	// An optional set of strings associated with the route for grouping and filtering.
	//
	Tags []string `json:"tags,omitempty"`
}

func (r RouteRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *RouteRequest) GetDestinations() []Destinations {
	if o == nil {
		return nil
	}
	return o.Destinations
}

func (o *RouteRequest) GetHeaders() *Headers {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *RouteRequest) GetHosts() []string {
	if o == nil {
		return nil
	}
	return o.Hosts
}

func (o *RouteRequest) GetHTTPSRedirectStatusCode() *HTTPSRedirectStatusCode {
	if o == nil {
		return nil
	}
	return o.HTTPSRedirectStatusCode
}

func (o *RouteRequest) GetMethods() []string {
	if o == nil {
		return nil
	}
	return o.Methods
}

func (o *RouteRequest) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *RouteRequest) GetPathHandling() *PathHandling {
	if o == nil {
		return nil
	}
	return o.PathHandling
}

func (o *RouteRequest) GetPaths() []string {
	if o == nil {
		return nil
	}
	return o.Paths
}

func (o *RouteRequest) GetPreserveHost() *bool {
	if o == nil {
		return nil
	}
	return o.PreserveHost
}

func (o *RouteRequest) GetProtocols() []string {
	if o == nil {
		return nil
	}
	return o.Protocols
}

func (o *RouteRequest) GetRegexPriority() *int64 {
	if o == nil {
		return nil
	}
	return o.RegexPriority
}

func (o *RouteRequest) GetRequestBuffering() *bool {
	if o == nil {
		return nil
	}
	return o.RequestBuffering
}

func (o *RouteRequest) GetResponseBuffering() *bool {
	if o == nil {
		return nil
	}
	return o.ResponseBuffering
}

func (o *RouteRequest) GetService() *RouteRequestService {
	if o == nil {
		return nil
	}
	return o.Service
}

func (o *RouteRequest) GetSnis() []string {
	if o == nil {
		return nil
	}
	return o.Snis
}

func (o *RouteRequest) GetSources() []Sources {
	if o == nil {
		return nil
	}
	return o.Sources
}

func (o *RouteRequest) GetStripPath() *bool {
	if o == nil {
		return nil
	}
	return o.StripPath
}

func (o *RouteRequest) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}
